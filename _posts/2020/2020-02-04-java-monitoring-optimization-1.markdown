---
layout:     post
title:      "Java监控与性能优化(一) 概况"
date:       2020-02-04
author:     "ZhouJ000"
header-img: "img/in-post/2020/post-bg-2020-headbg.jpg"
catalog: true
tags:
    - java
    - 优化
--- 

[Java性能优化01-程序优化](https://zhouj000.github.io/2019/01/06/java-optimize-01/)  
[Java性能优化02-并行优化](https://zhouj000.github.io/2019/01/08/java-optimize-02/)  
[Java性能优化03-JVM调优](https://zhouj000.github.io/2019/01/10/java-optimize-03/)  
[Java性能优化04-调优工具](https://zhouj000.github.io/2019/01/11/java-optimize-04/)  

[Java监控与性能优化(一) 概况](https://zhouj000.github.io/2020/02/04/java-monitoring-optimization-1/)  




# 性能分析

#### 自顶向下

自顶向下是最常见的性能调优方式，其着眼于软件栈顶层的应用，从上往下找寻优化机会和问题，应用开发人员使用较多。如果调优涉及软件栈顶层应用代码的更改，也常使用这种方式

自顶向下时，通常会从发现性能问题的负载开始监控应用。应用的配置变化和日常负荷变化都可能导致性能降低，所以需要持续监控应用。此外，一旦应用的性能和扩展性需求发生变化，应用就可能无法满足新要求，所以也要监控应用程序的性能

因此自顶向下的第一步总是对运行在特定负载下的应用进行监控，监控范围包括操作系统、Java虚拟机、Java EE容器以及应用的性能测量统计指标。基于监控信息指标给出的提示再展开下一步的工作，比如JVM垃圾收集器调优、JVM命令行选项调优、操作系统调优或应用程序性能分析。应用程序性能分析又可能导致应用程序的更改，或第三方库或Java SE类库在实现上的不足

#### 自底向上

在不同平台(底层CPU架构或CPU数量不同)上进行应用系统调优时，或将应用迁移到其他操作系统上，性能专家常使用自底向上的方法，用以辨别因不同硬件架构、操作系统或不同Java虚拟机实现导致的性能差异。在无法更改应用源代码时，也常使用这种方式

自底向上需要收集和监控最底层CPU的性能统计数据。监控的CPU数据包括执行特定任务所需要的CPU指令数，以及应用在一定负载下运行时CPU告诉缓存命中率，虽然还有其他重要的CPU统计数据，但这2个是自底向上中最常用的。在一定负载下，应用执行和扩展的CPU指令越少，应用就越快；同样CPU缓存命中率高，能减少CPU从内存取数据的等待时间，应用也就运行更快



# Java应用性能分析

+ 性能的定义
	- 响应性 Response
	- 吞吐量 Throughput
+ 性能分析方法
	- 方法分析
	- 内存分析
+ 性能分析技巧
	- 性能优化机会
		+ 使用更高效的算法
		+ 为算法生成更有效的代码
		+ 减少锁竞争
			- 采用Java SE中的原子并发数据结构
			- 合理设计应用程序，减少多线程访问同一数据的频率，缩小并发访问范围
	- 减少系统(内核)态CPU的使用
		+ 监控操作系统在系统或内核态上CPU的使用情况
		+ 减少I/O系统调用的频率
			- 缓存数据
			- 批量读取或批量写入
			- 使用Java NIO非阻塞数据结构
	- 合理定义volatile字段
	- 调整数据结构的大小
	- 增加并行性

# JVM性能调优

+ 方法
	- 分析系统需求，划分优先级
		+ 可用性、可管理性、吞吐量、延迟及响应性、内存占用、启动时间
	- 选择JVM部署方式
		+ 单JVM与多JVM
		+ 32位JVM与64位JVM
		+ Client模式与Server模式
	- 选择JVM运行时
	- 调优应用程序内存使用
	- 调优应用程序延迟
	- 调优应用程序吞吐量
+ 垃圾收集器
	- Serial收集器
	- Throughput收集器
	- Mostly-Concurrent收集器
	- G1收集器
	- 垃圾收集三个基本原则
		+ Minor GC回收原则：每次Minor GC都尽可能多地收集垃圾对象
		+ GC内存最大化原则：处理吞吐量和延迟问题时，垃圾处理器能使用的内存越大，垃圾收集效果越好
		+ GC调优的3选2原则：吞吐量、延迟、内存占用中任意选择2个进行JVM垃圾收集器调优
+ 性能属性
	- 吞吐量
	- 延迟
	- 内存占用

# 内存管理策略

+ 应用程序显式管理内容可能产生的问题
	- 引用悬空
	- 内存泄露
+ 由系统自动管理内存
	- 垃圾收集器GC概念
		+ 目的：为新建的内存分配腾出空间
		+ 确保被引用的对象保持在内存中
		+ 回收代码执行过程中不可达对象占用的内存空间
	- 大多数动态内存分配面临的问题
		+ 如何避免内存空间碎片化
	- 内存管理策略设计的考量点
		+ 采用Serial收集器还是Parallel收集器
		+ 采用Most-Concurrent收集器让应用线程和垃圾收集器并行运行，还是暂停所有线程进行垃圾收集STW
		+ 垃圾收集采用标记-压缩算法，还是复制算法
	- 性能指标
		+ 对应用吞吐量的影响
		+ 对应用响应性的影响
		+ 垃圾收集的开销
		+ 垃圾收集导致的应用停顿时间
		+ 垃圾收集的频率
		+ 垃圾收集器自身的内存占用


参考：  
《Java性能优化权威指南》  
